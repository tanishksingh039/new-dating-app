rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Users collection
    match /users/{userId} {
      // Anyone authenticated can read user profiles (for discovery)
      allow read: if isAuthenticated();
      
      // Only the user can create/update their own profile
      allow create: if isOwner(userId);
      
      // Allow updates if:
      // 1. User is updating their own profile, OR
      // 2. User is updating match-related fields (for mutual matching)
      allow update: if isOwner(userId) || 
                       (isAuthenticated() && 
                        request.resource.data.diff(resource.data).affectedKeys()
                          .hasOnly(['matches', 'matchCount', 'lastActive']));
      
      // Only the user can delete their own profile
      allow delete: if isOwner(userId);
      
      // Likes subcollection - tracks who this user liked
      match /likes/{targetUserId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }
      
      // Received likes subcollection - tracks who liked this user
      match /receivedLikes/{senderId} {
        allow read: if isOwner(userId);
        allow write: if isAuthenticated(); // Others can write when they like
      }
      
      // Super likes subcollection
      match /superLikes/{targetUserId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }
      
      // Received super likes subcollection
      match /receivedSuperLikes/{senderId} {
        allow read: if isOwner(userId);
        allow write: if isAuthenticated();
      }
      
      // Passes subcollection - tracks who this user passed on
      match /passes/{targetUserId} {
        allow read: if isOwner(userId);
        allow write: if isOwner(userId);
      }
    }
    
    // Matches collection
    match /matches/{matchId} {
      // Helper to check if user is participant in the match
      function isMatchParticipant() {
        return request.auth.uid in resource.data.users;
      }
      
      // Helper to check if user will be participant (for creates)
      function willBeParticipant() {
        return request.auth.uid in request.resource.data.users;
      }
      
      // Allow reading if:
      // 1. Document exists and user is a participant, OR
      // 2. User is authenticated (to check if match exists before creating)
      allow read: if isAuthenticated();
      
      // Allow creating if user will be a participant in the new match
      allow create: if isAuthenticated() && willBeParticipant();
      
      // Allow updating/deleting only if user is a participant
      allow update: if isAuthenticated() && isMatchParticipant();
      allow delete: if isAuthenticated() && isMatchParticipant();
    }
    
    // Chats collection
    match /chats/{chatId} {
      // Extract user IDs from chatId (format: userId1_userId2)
      function getChatUsers() {
        return chatId.split('_');
      }
      
      // Check if current user is part of this chat
      function isParticipant() {
        return isAuthenticated() && 
               request.auth.uid in getChatUsers();
      }
      
      allow read: if isParticipant();
      allow write: if isParticipant();
      
      // Messages subcollection
      match /messages/{messageId} {
        allow read: if isParticipant();
        allow create: if isParticipant();
        allow update: if false; // Messages cannot be edited
        allow delete: if false; // Messages cannot be deleted
      }
    }
    
    // Swipes collection (centralized tracking)
    match /swipes/{swipeId} {
      allow read: if isAuthenticated() && 
                     (request.auth.uid == resource.data.userId || 
                      request.auth.uid == resource.data.targetUserId);
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.userId;
      allow update: if false; // Swipes cannot be modified
      allow delete: if isOwner(resource.data.userId); // Only swiper can undo
    }
    
    // Block any other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
